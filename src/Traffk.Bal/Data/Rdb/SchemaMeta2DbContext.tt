<#@ template language="C#" debug="false" hostspecific="true"#>
<#@ output extension=".cs"#>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml.XPath" #>
<#@ import namespace="System.Text" #>
<#@ include file="MultipleOutputHelper.ttinclude"#>
<#
var details = new List<Tuple<string, string, string, string>>
{
	Tuple.Create("TraffkTenantShardManager.SchemaMeta.xml", "TraffkTenantShardManager.DbContext.cs", "Traffk.Bal.Data.Rdb.TraffkTenantShardManager", "TraffkTenantShardManagerDbContext"),
//	Tuple.Create("TraffkTenantShards.SchemaMeta.xml", "TraffkTenantShards.DbContext.cs", "Traffk.Bal.Data.Rdb.TraffkTenantShards", "TraffkTenantShardsDbContext")
	Tuple.Create("TraffkGlobal.SchemaMeta.xml", "TraffkGlobal.DbContext.cs", "Traffk.Bal.Data.Rdb.TraffkGlobal", "TraffkGlobalDbContext"),
	Tuple.Create("TraffkTenantModel.SchemaMeta.xml", "TraffkTenantModel.DbContext.cs", "Traffk.Bal.Data.Rdb.TraffkTenantModel", "TraffkTenantModelDbContext"),
	Tuple.Create("ReferenceData.SchemaMeta.xml", "ReferenceData.DbContext.cs", "Traffk.Bal.Data.Rdb.ReferenceDataModel", "ReferenceDataDbContext")
};
#>
<#
var manager = Manager.Create(Host, GenerationEnvironment);
foreach (var d in details)
{
    manager.StartNewFile(d.Item2);
	string databaseContextClassName = d.Item4;
	string schemaMetaFile = d.Item1;
	string outputNamespace = d.Item3;
	var schemaMetaFullPath = this.Host.ResolvePath(schemaMetaFile);
	var doc = XDocument.Load(schemaMetaFullPath);
	var tablesInDbContext = new HashSet<string>();
#>/*
This was autogenerated
DO NOT MODIFY BY HAND!!!
TT File: Rdb.Schema.tt
XML File: <#=schemaMetaFullPath#>
Generation Time: <#=DateTime.Now#>
*/
using Microsoft.EntityFrameworkCore;
using Newtonsoft.Json;
using RevolutionaryStuff.Core;
using RevolutionaryStuff.Core.ApplicationParts;
using RevolutionaryStuff.Core.Database;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Data;
using System.Data.SqlClient;
using System.Threading.Tasks;
using System.Runtime.Serialization;

namespace <#=outputNamespace#>
{
    public partial class <#=databaseContextClassName#>
    {
		protected override void OnModelCreating(ModelBuilder modelBuilder)
		{
            base.OnModelCreating(modelBuilder);
<#
foreach (var z in doc.XPathSelectElements("/SchemaMeta/Tables/Table[Properties/Property/@name='AddToDbContext']"))
{
			if (GetPropertyValue(z, "AddToDbContext")!="1") continue;
			var descriminator = z.XPathSelectElements("Columns/Column[Properties/Property/@name='IsInheritanceDiscriminatorField']").FirstOrDefault() as XElement;
			if (descriminator==null) continue;
			var superclass = GetClassName(z);
			var descriminatorProperty = descriminator.Attribute("name").Value;
			if (z.XPathSelectElements("Columns/Column[@name='"+descriminatorProperty+"']/Properties/Property[@name='EnumType']").FirstOrDefault()!=null)
			{
				descriminatorProperty += "StringValue";
			}
#>
			modelBuilder.Entity<<#=superclass#>>()
				.HasDiscriminator<string>(nameof(<#=superclass#>.<#=descriminatorProperty#>))
<#
	foreach (XElement icp in z.XPathSelectElements("Properties/Property"))
	{
		var icpn = RightOf(icp.Attribute("name").Value, "InheritanceClass:");
		if (icpn==null) continue;
		icpn = LeftOf(icpn, ",");
#>
				.HasValue<<#=icpn#>>("<#=icp.Attribute("value").Value#>")
<#
	}
#>
				;
<#
}
#>
		}

		#region Collections

<#
foreach (var z in doc.XPathSelectElements("/SchemaMeta/Tables/Table[Properties/Property/@name='AddToDbContext']").OrderBy(wq=>GetClassName(wq)))
{
		if (GetPropertyValue(z, "AddToDbContext")!="1") continue;
		var schemaTable = GetAttrVal(z, "schema") + "." + GetAttrVal(z, "name");
		tablesInDbContext.Add(schemaTable);
#>		
		public DbSet<<#=GetClassName(z)#>> <#=z.Attribute("name").Value#> { get; set; } //<#=schemaTable#>

<#
	foreach (XElement icp in z.XPathSelectElements("Properties/Property"))
	{
		var icpn = RightOf(icp.Attribute("name").Value, "InheritanceClass:");
		if (icpn==null) continue;
		var className = LeftOf(icpn, ",");
		var collName = RightOf(icpn, ",");
		if (collName==null) continue;
#>
		public DbSet<<#=className#>> <#=collName#> { get; set; }

<#
	}
}
#>
		#endregion

		#region Sprocs

<#
foreach (var z in doc.XPathSelectElements("/SchemaMeta/Sprocs/Sproc[Properties/Property/@name='AddToDbContext']"))
{
	var sprocType = GetPropertyValue(z, "SprocType") ?? "NonQuery";
	if (sprocType=="void") sprocType = "NonQuery";
	var isCollection = sprocType.StartsWith("Collection");
	var isSpecificCollection = sprocType.StartsWith("Collection:");
	var tenantIdParameterName = GetPropertyValue(z, "TenantIdParameterName");
	string collectionType = null;
	string collectionTypeConstraint = "";
	if (isSpecificCollection)
	{
		collectionType = sprocType.Substring(11);
	}
	else if (isCollection)
	{
		collectionType = "TItem";
		collectionTypeConstraint = "where TItem : new()";
	}
	var isReader = sprocType == "Reader";
	var isNonQuery = sprocType == "NonQuery";
	var sprocNameSuffix = isReader ? "Reader" : "";
	var accessModifier = GetPropertyValue(z, "AccessModifier") ?? "public";
#>
		<#=accessModifier#> async Task<ConnectionHelpers.Result<#=isCollection?"<"+collectionType+">":""#>> <#=GetSprocName(z)#><#=sprocNameSuffix#>Async<#=collectionTypeConstraint==""?"":"<"+collectionType+">"#>(<#
		int argNum = 0;
foreach (var a in z.XPathSelectElements("Args/Arg"))
{
	bool nullable = true;
	string dataType = GetPropertyValue(a, "EnumType") ?? SqlTypeToClrType(GetAttrVal(a, "sqlType"));
	if (dataType=="string")
	{
		nullable = false;	
	}
	var memberName = GetAttrVal(a, "name").Substring(1);
	if (memberName==tenantIdParameterName) continue;
	#><#=argNum==0?"":", "#><#=dataType#><#=nullable?"?":""#> <#=memberName#> = null<#
	++argNum;
}
if (isReader)
{#>, params Action<IDataReader>[] actions<#}#>) <#=collectionTypeConstraint#>
		{
            var ps = new SqlParameter[]
                {
<#foreach (var a in z.XPathSelectElements("Args/Arg"))
{
	var memberName = GetAttrVal(a, "name").Substring(1);
	bool nullable = true;
	bool convertToString = GetPropertyValue(a, "EnumType") != null;
	switch (GetAttrVal(a, "sqlType"))
	{
		case "nvarchar":
		case "varchar":
			nullable = false;
			break;
	}
	string direction = GetAttrVal(a, "mode");
	switch (direction)
	{
		case "OUT":
			direction = "ParameterDirection.Output";
			break;
		case "IN":
			direction = "ParameterDirection.Input";
			break;
		default:
			throw new Exception("unrecognized direction "+direction);
	}
#>                    new SqlParameter("<#=GetAttrVal(a, "name")#>", <#=memberName#>==null ? DBNull.Value:(object) <#=memberName#><#=convertToString?".ToString()":""#>){Direction=<#=direction#>},
<#
}
#>
                };
            var conn = Database.GetDbConnection();
			if (conn.State!=ConnectionState.Open)
			{
	            await conn.OpenAsync();
			}
<#
			if (isNonQuery)
			{
#>            return await conn.ExecuteNonQueryAsync(null, "<#=GetAttrVal(z, "schema")#>.<#=GetAttrVal(z, "name")#>", null, ps);
<#
			}
			else if (isReader)
			{
#>            return await conn.ExecuteReaderForEachAsync(null, "<#=GetAttrVal(z, "schema")#>.<#=GetAttrVal(z, "name")#>", null, ps, actions);
<#			
			}
			else if (isCollection)
			{
#>            return await conn.ExecuteReaderAsync<<#=collectionType#>>(null, "<#=GetAttrVal(z, "schema")#>.<#=GetAttrVal(z, "name")#>", null, ps);
<#			
			}
#>
		}

<#
}
#>
		#endregion

	}
<#
foreach (var z in doc.XPathSelectElements("/SchemaMeta/Tables/Table[Properties/Property/@name='GeneratePoco'=\"zzd\"]"))
{
	if (GetPropertyValue(z, "GeneratePoco")!="1") continue;
	var classNames = new List<string>();
	classNames.Add(GetClassName(z));
	bool inheritance = false;
	string inheritanceClassDiscriminatorValue = null;
	foreach (XElement icp in z.XPathSelectElements("Properties/Property"))
	{
		var icpn = RightOf(icp.Attribute("name").Value, "InheritanceClass:");
		if (icpn==null) continue;
		classNames.Add(LeftOf(icpn, ","));
		inheritanceClassDiscriminatorValue = icp.Attribute("value").Value;
		inheritance = true;
	}
	if (inheritance) classNames.Add(classNames[0]+"AllFields");
	for (int classNameIndex=0;classNameIndex<classNames.Count;++classNameIndex)
	{
	var className = classNames[classNameIndex];
	var isAllFields = classNameIndex==classNames.Count-1 && classNameIndex>0;
	var constructorAccessModifier = isAllFields ? "private" : "public";
#>

<#
	string comment;
	comment = GetPropertyValue(z, "Comment");

	if (comment!=null)
	{
#>
	/// <summary>
	/// <#=comment#>
	/// </summary>
<#
	}

	var isAbstract = inheritance == true;
	var jsonSettingsPresavers = new Dictionary<string, string>();
	string superclass = null;
	if (inheritance && className != classNames[0])
	{
		superclass = classNames[0];
	}
	var copyConstructorFieldNames = new List<string>();
	string primaryKeyPropertyName = null;
	string primaryKeyTypeName = null;
	foreach (var pkc in z.XPathSelectElements("Columns/Column[@isPrimaryKey=\"1\"]"))
	{
		primaryKeyTypeName = SqlTypeToClrType(GetAttrVal(pkc, "sqlType"));
	}
	var keyPropertyNames = new List<string>();
	var implements = GetPropertyValue(z, "Implements");
	var validators = new List<string>();
#>
	[Table("<#=GetAttrVal(z, "name")#>", Schema = "<#=GetAttrVal(z, "schema")#>")]
<#
	if (GetPropertyValue(z, "CustomAttribute")!=null)
	{
#>	[<#=GetPropertyValue(z, "CustomAttribute")#>]
<#		
	}
	if (superclass==null)
	{
#>
	public <#=isAbstract?"abstract ":""#>partial class <#=className#> : IRdbDataEntity, IValidate, IPreSave<#=implements==null?"":", "+implements#><#=primaryKeyTypeName==null?"":", IPrimaryKey<"+primaryKeyTypeName+">"#>
	{
        public static readonly <#=className#>[] None = new <#=className#>[0];
<#	
	}
	else
	{
#>
	public partial class <#=className#> : <#=superclass#>
	{
        public static new readonly <#=className#>[] None = new <#=className#>[0];
<#		
	}
#>

<#
if (superclass==null) foreach (var ip in z.XPathSelectElements("Collections/Collection"))
{
	var schemaTable = GetAttrVal(ip, "schema") + "." + GetAttrVal(ip, "table");
	if (!tablesInDbContext.Contains(schemaTable))
	{
	#>
		//skipped: <#=schemaTable#>

<#
	 continue;
	}

	var inversePropertyTypeName = GetClassName(doc, GetAttrVal(ip, "schema"), GetAttrVal(ip, "table"));
	var inversePropertyFieldName = GetPropertyNameFromColumnName(GetAttrVal(ip, "column"))+inversePropertyTypeName+"s";
	copyConstructorFieldNames.Add(inversePropertyFieldName);
#>
		[InverseProperty("<#=GetPropertyNameFromColumnName(GetAttrVal(ip, "column"))#>")]
		[JsonIgnore]
        [IgnoreDataMember]
        public List<<#=inversePropertyTypeName#>> <#=inversePropertyFieldName#> { get; set; } = new List<<#=inversePropertyTypeName#>>();

<#
}
foreach (var f in z.XPathSelectElements("Columns/Column"))
{
	var accessModifier = GetPropertyValue(f, "AccessModifier") ?? "public";
	if (accessModifier=="missing") continue;
	if (inheritance)
	{
		if (GetPropertyValue(f, "IsInheritanceDiscriminatorField")=="1")
		{
//			continue;
		}
		bool isInheritedField = false;
		bool isInheritedFieldInThisSubsclass = isAllFields;
		foreach (XElement prop in f.XPathSelectElements("Properties/Property[@name='InheritanceField']"))
		{
			var ifcn = GetAttrVal(prop, "value");
			isInheritedField = true;
			if (LeftOf(ifcn, ",")==className)
			{
				isInheritedFieldInThisSubsclass = true;
				break;
			}
		}	
		if (isInheritedField && !isInheritedFieldInThisSubsclass) continue;
		if (!isInheritedField && superclass!=null) continue;
	}
	string propertyName = GetAttrVal(f, "name");
	if (propertyName==className)
	{
		propertyName = propertyName + "Property";
	}
	comment = GetPropertyValue(f, "MS_Description");
	var dataAnnotation = GetPropertyValue(f, "DataAnnotation");
	var customAttributeNames = GetPropertyValue(f, "CustomAttribute");
	var displayName = GetPropertyValue(f, "DisplayName") ?? ToTitleFriendlyString(propertyName);
	var sampleData = GetPropertyValue(f, "SampleData");
	bool isPrimaryKey = GetAttrValAsBool(f, "isPrimaryKey");
	var addToCopyConstructor = !isPrimaryKey;
	if (isPrimaryKey)
	{
		primaryKeyPropertyName = propertyName;
	}
	bool isNullable;
	string maxLen;
	string jsonSettingsClass;
	string dataType = GetClrTypeFromColumn(f, out isNullable, out maxLen, out jsonSettingsClass);
	if (isPrimaryKey)
	{
#>
		object IPrimaryKey.Key { get { return <#=propertyName#>; }}
	
		<#=primaryKeyTypeName#> IPrimaryKey<<#=primaryKeyTypeName#>>.Key { get { return <#=propertyName#>; }}

<#
	}

	if (comment!=null)
	{
#>
		/// <summary>
		/// <#=comment#>
		/// </summary>
		[Description("<#=EscapeForCSharpStringEmbed(comment)#>")]
<#
	}
	if (displayName!=null)
	{
#>		[DisplayName("<#=EscapeForCSharpStringEmbed(displayName)#>")]
<#	
	}
	string enumType = GetPropertyValue(f, "EnumType");
	if (enumType!=null)
	{
		var enumPropertyName = propertyName;
		propertyName += "StringValue";
#>
		[NotMapped]
		public <#=enumType#> <#=enumPropertyName#>
        {
            get
            {
                <#=enumType#> e;
                if (Enum.TryParse(<#=propertyName#>, true, out e)) return e;
                return 0;
            }
            set { <#=propertyName#> = value.ToString(); }
        }

<#
	}
	if (jsonSettingsClass!=null)
	{
		var settingsPropertyName = propertyName;
		var settingsFieldName = settingsPropertyName+"_p";
		propertyName = propertyName+"Json";
		jsonSettingsPresavers[settingsFieldName] = propertyName;
#>
		partial void On<#=settingsPropertyName#>Deserialized();

        [NotMapped]
        public <#=jsonSettingsClass#> <#=settingsPropertyName#>
        {
            get
            {
                if (<#=settingsFieldName#> == null)
                {
                    <#=settingsFieldName#> = <#=jsonSettingsClass#>.CreateFromJson(<#=propertyName#>) ?? new <#=jsonSettingsClass#>();
					On<#=settingsPropertyName#>Deserialized();
                }
                return <#=settingsFieldName#>;
            }
            set { <#=settingsFieldName#> = value; }
        }
        private <#=jsonSettingsClass#> <#=settingsFieldName#>;

<#
	}
	if (sampleData!=null)
	{
#>		[SampleData("<#=sampleData#>")]
<#
	}
	if (dataType=="string" && !isNullable)
	{
		validators.Add("Requires.NonNull("+propertyName+", nameof("+propertyName+"));");
#>		[NotNull]
		[Required]
<#
	}
	if (isPrimaryKey)
	{
		keyPropertyNames.Add(propertyName);
#>		[Key]
<#
	}
	if (dataAnnotation!=null)
	{
#>		[<#=dataAnnotation#>]
<#			
	}
	if (customAttributeNames!=null)
	{
#>		[<#=customAttributeNames#>]
<#		
	}
	if (maxLen != null)
	{
		validators.Add("Requires.Text("+propertyName+", nameof("+propertyName+"), true, 0, "+maxLen+");");
#>		[MaxLength(<#=maxLen#>)]
<#
	}
	if (propertyName.StartsWith("CreatedAt", System.StringComparison.CurrentCultureIgnoreCase) ||
		GetAttrValAsBool(f, "isComputed")
	)
	{
		addToCopyConstructor = false;
#>		[DatabaseGenerated(DatabaseGeneratedOption.Computed)]
<#
	}
	else if (GetAttrVal(f, "isIdentity")=="1")
	{
#>		[DatabaseGenerated(DatabaseGeneratedOption.Identity)]
<#
	}
#>
		[Column("<#=GetAttrVal(f, "name")#>")]
		<#=accessModifier#> <#=dataType#> <#=propertyName#> { get; set; }

<#
	if (GetAttrVal(f, "refTable")!=null || GetPropertyValue(f, "LinksTo")!=null)
	{
		var refSchema = GetAttrVal(f, "refSchema") ?? LeftOf(GetPropertyValue(f, "LinksTo"), ".");
		var refTable = GetAttrVal(f, "refTable") ?? RightOf(LeftOf(GetPropertyValue(f, "LinksTo"), "("), ".");
#>
		//LinksTo:<#=refSchema#>.<#=refTable#>
		[ForeignKey("<#=GetAttrVal(f, "name")#>")]
		[JsonIgnore]
        [IgnoreDataMember]
		<#=accessModifier#> <#=GetClassName(doc, refSchema, refTable)#> <#=GetPropertyNameFromColumnName(propertyName)#> { get; set; }

<#	
	}
	if (propertyName.EndsWith("Utc", System.StringComparison.CurrentCultureIgnoreCase) && dataType.StartsWith("DateTime", System.StringComparison.CurrentCultureIgnoreCase))
	{
		var localTimePropertyName = RemoveFinalNCharacters(propertyName,3);
#>
		[DisplayName("<#=ToTitleFriendlyString(localTimePropertyName)#>")]
		[NotMapped]
		[JsonIgnore]
        [IgnoreDataMember]
		<#=accessModifier#> <#=dataType#> <#=localTimePropertyName#> => <#=propertyName#><#=isNullable?"?":""#>.ToLocalTime();

<#	
	}
	if (addToCopyConstructor)
	{
		copyConstructorFieldNames.Add(propertyName);
	}
}
#>
		partial void OnToString(ref string extras);

        public override string ToString()
		{
			string extras = null;
			OnToString(ref extras);
			return $"{GetType().Name} <#
foreach (var kpn in keyPropertyNames)
{
#><#=kpn#>={<#=kpn#>}<#
}
#> {extras}";
		}

		partial void OnConstructed();
	
		<#=constructorAccessModifier#> <#=className#>()
			: this(null)
		{}

		<#=constructorAccessModifier#> <#=className#>(<#=className#> other, bool copyKey=false)<#=superclass==null?"":"\n\t\t\t: base(other)"#>
		{
			if (other!=null)
			{
<#if(primaryKeyPropertyName!=null){
#>
				if (copyKey)
				{
					<#=primaryKeyPropertyName#> = other.<#=primaryKeyPropertyName#>;
				}
<#
}
foreach (var ccfn in copyConstructorFieldNames)
{
#>
				<#=ccfn#> = other.<#=ccfn#>;
<#
}
#>			}
			OnConstructed();
		}

		partial void PartialPreSave();

<#	
if (superclass==null)
{
#>		void IPreSave.PreSave()
        {
			OnPreSave();
		}

		protected virtual void OnPreSave()
		{
<#
}
else
{
#>		protected override void OnPreSave()
		{
			base.OnPreSave();
<#	
}
#>
<#
foreach (var kvp in jsonSettingsPresavers)
{
#>
            if (<#=kvp.Key#> != null)
            {
				var json = <#=kvp.Key#>.ToJson();
				if (<#=kvp.Value#> != json)
				{
					<#=kvp.Value#> = json;
				}				 
            }
<#}
#>
			PartialPreSave();
        }

		partial void PartialValidate();

<#	
if (superclass==null)
{
#>		public virtual void Validate()
        {
<#
}
else
{
#>		public override void Validate()
        {
			base.Validate();
<#
}
#>
<#
foreach (var v in validators)
{
#>
			<#=v#>
<#}
#>
			PartialValidate();
        }
	}
<#}
}
#>
}
<#
}
manager.Process(true);
#><#+
public bool GetAttrValAsBool(XElement xel, string attrName)
{
	string val = GetAttrVal(xel, attrName);
	return (val=="1") || (val=="true");
}
public string GetAttrVal(XElement xel, string attrName)
{
	var a = xel.Attribute(attrName);
	return a==null?null:a.Value;
}
public string GetPropertyValue(XElement xel, string propertyName)
{
	var xpath = "Properties/Property[@name='"+propertyName+"']/@value";
	var res = ((IEnumerable<object>)xel.XPathEvaluate(xpath)).Cast<XAttribute>().FirstOrDefault();
	if (res==null) return null;
	return res.Value;
}
public string GetClassName(XElement tableElement)
{
	var name = GetPropertyValue(tableElement, "ClassName");
	if (name==null)
	{
		name = tableElement.Attribute("name").Value;
		if (name.Length>3 && name.Substring(name.Length-3)=="ies")
		{
			name = name.Substring(0, name.Length-3)+"y";
		}
		else if (name[name.Length-1]=='s')
		{
			name = name.Substring(0, name.Length-1);
		}
	}
	return name;
}
public string GetSprocName(XElement tableElement)
{
	var name = GetPropertyValue(tableElement, "SprocName");
	if (name==null)
	{
		name = tableElement.Attribute("name").Value;
	}
	return name;
}
public string GetClassName(XDocument doc, string schemaName, string tableName)
{
	var tableElement = doc.XPathSelectElements("/SchemaMeta/Tables/Table[@name='"+tableName+"']").FirstOrDefault();
	return GetClassName(tableElement);
}
public string GetPropertyNameFromColumnName(string propertyName)
{
	return RemoveFinalNCharacters(propertyName, 2);
}
public string RemoveFinalNCharacters(string s, int n)
{
	return s.Substring(0, s.Length-n);
}
public string RightOf(string s, string pivot)
{
	if (s==null) return null;
	var x = s.IndexOf(pivot);
	if (x<0) return null;
	return s.Substring(x+pivot.Length);
}
public string LeftOf(string s, string pivot)
{
	if (s==null) return null;
	var x = s.IndexOf(pivot);
	if (x<0) return s;
	return s.Substring(0, x);
}

public string GetClrTypeFromColumn(XElement f, out bool isNullable, out string maxLen, out string jsonSettingsClass)
{
	isNullable = GetAttrValAsBool(f, "isNullable");
	maxLen = null;
	jsonSettingsClass = null;
	string dataType = null;
	bool canUseMaxLen = false;
	switch (GetAttrVal(f, "sqlType"))
	{
		case "uniqueidentifier":
			dataType = "Guid";
			break;
		case "smallint":
			dataType = "int" + (isNullable ? "?" : "");//should be a ushort, but EF doesn't like that type with SQL Server
			break;
		case "tinyint":
			dataType = "byte" + (isNullable ? "?" : "");
			break;
		case "money":
		case "numeric":
			dataType = "decimal" + (isNullable ? "?" : "");
			break;
		case "float":
			dataType = "double" + (isNullable ? "?" : "");
			break;
		case "int":
			dataType = "int" + (isNullable ? "?" : "");
			break;
		case "bigint":
			dataType = "long" + (isNullable ? "?" : "");
			break;
		case "char":
			dataType = isNullable ? "string" : "char";
			break;
		case "bit":
			dataType = "bool" + (isNullable ? "?" : "");
			break;
		case "datetime2":
		case "datetime":
		case "date":
			dataType = "DateTime" + (isNullable ? "?" : "");
			break;
		case "varbinary":
		case "binary":
			dataType = "byte[]";
			break;
		case "nvarchar":
		case "varchar":
			canUseMaxLen = true;
			dataType = "string";
			jsonSettingsClass = GetPropertyValue(f, "JsonSettingsClass");
			break;
		default:
			dataType = "object";
			break;
	}
	if (canUseMaxLen)
	{
		maxLen = GetAttrVal(f, "maxLen");
		if (maxLen=="-1") maxLen = null;	
	}
	return dataType;
}
public string SqlTypeToClrType(string sqlType)
{
	switch (sqlType)
	{
		case "uniqueidentifier":
			return "Guid";
		case "smallint":
			return "int";//should be a ushort, but EF doesn't like that type with SQL Server
		case "tinyint":
			return "byte";
		case "money":
		case "numeric":
			return "decimal";
		case "float":
			return "double";
		case "int":
			return "int";
		case "bigint":
			return "long";
		case "char":
			return "char";
		case "bit":
			return "bool";
		case "datetime2":
		case "datetime":
		case "date":
			return "DateTime";
		case "nvarchar":
		case "varchar":
			return "string";
		default:
			return "object";
	}	
}
public static string EscapeForCSharpStringEmbed(string s)
{
	if (s==null) return null;
	return s.Replace("\\","\\\\").Replace("\"", "\\\"");
//	return System.Security.SecurityElement.Escape(s);
}
public static string ToTitleFriendlyString(string s)
{
    var sb = new StringBuilder();
    bool lastWasUpper = false;
    bool lastWasUnderscore = false;
    for (int x = 0; x < s.Length; ++x)
    {
        var ch = s[x];
        if (char.IsUpper(ch))
        {
            if (!lastWasUpper && x>0)
            {
                sb.Append(' ');
            }
            lastWasUpper = true;
            lastWasUnderscore = false;
        }
        else if (ch == '_')
        {
            ch = ' ';
            lastWasUnderscore = true;
        }
        else
        {
            if (lastWasUnderscore || x==0)
            {
                ch = char.ToUpper(ch);
            }
            lastWasUpper = false;
            lastWasUnderscore = false;
        }
        sb.Append(ch);
    }
    return sb.ToString();
}
#>